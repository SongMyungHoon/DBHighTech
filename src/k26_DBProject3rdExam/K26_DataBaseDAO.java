package k26_DBProject3rdExam;

import java.sql.*;
import java.util.*;

public class K26_DataBaseDAO {
	private static final String k26_ID = "root";			// DB 접속 ID
	private static final String k26_PASSWORD = "qortjf90";	// DB 접속 Password
	
	// K26_DataBaseDAO Class의 공용 Connection 객체
	private static Connection k26_connection = null;
	private static String k26_DBName = "";		// 접속할 DB name
	private static String k26_tableName = "";	// 물품 정보가 저장된 table의 name
	
	// Class 내부에서 공용으로 String manipulation을 담당할 StringBuilder instance
	private static StringBuilder k26_stringBuilder = new StringBuilder();
	
	public String k26_getDBName() {
		return k26_DBName;
	}

	public void k26_setDBName(String k26_inputDBName) {
		k26_DBName = k26_inputDBName;
	}
	
	
	public static String k26_getTableName() {
		return k26_tableName;
	}

	public void k26_setTableName(String k26_tableName) {
		K26_DataBaseDAO.k26_tableName = k26_tableName;
	}
	
	/**k26_connectDB method
	 * DB와의 connection을 수행하는 method로 K26_DataBaseDAO Class의 공용 connection instance에
	 * connection 정보를 저장하고 해당 공용 connection을 공유하는 형태로 DAO class 설계
	 * @return void
	 */
	public void k26_connectDB () {
		String k26_useDB_SERVER = "localhost:3306";
		String k26_useDB_URL_Option = k26_stringBuilder.append("?useUnicode=true&characterEncoding=utf8")
					.append("&serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true")
					.append("&useSSL=false").toString();

		k26_stringBuilder.setLength(0);
		String k26_DB_URL = k26_stringBuilder.append("jdbc:mysql://").append(k26_useDB_SERVER)
				.append("/").append(k26_useDB_URL_Option).toString();
		k26_stringBuilder.setLength(0);
		
		try {	// driver 존재 여부 확인
			Class.forName("com.mysql.cj.jdbc.Driver");
		} catch (ClassNotFoundException k26_Error) {
		    System.out.println("ERROR] JDBC Driver load: \n" + k26_Error.getMessage());
		    k26_Error.printStackTrace();
		}
		
		
		try {	// Open a connection
			k26_connection = DriverManager.getConnection(k26_DB_URL, k26_ID, k26_PASSWORD);
		} catch (SQLException k26_Error) {
			System.out.println("Error] Connection fail: \n" + k26_Error.getMessage());
			k26_Error.printStackTrace();
		}
	}
	
	/**k26_setDB method
	 * 설정된 k26_DBName과 동일한 DB가 존재하는지 확인하고, 없는 경우
	 * k26_DBName으로 DB 생성 후 DB 사용 전환
	 * @return void
	 */
	public void k26_setDB() {
		PreparedStatement k26_preStatement = null;
		ResultSet k26_resultSet = null;
		try {
			// MySQL에서 접근 가능한 DB 중 k26_DBNAme에 해당하는 DB를 select로 조회
			String k26_DBSql = "SELECT * FROM Information_schema.SCHEMATA WHERE SCHEMA_NAME = ?";
			k26_preStatement = k26_connection.prepareStatement(k26_DBSql);
			k26_preStatement.setString(1, k26_DBName);
			/**
		     * Executes the SQL query in this PreparedStatement object
		     * and returns the ResultSet object generated by the query.
		     *
		     * @return a ResultSet object that contains the data produced by the query;
		     * 		   never null
		     * @exception SQLException if a database access error occurs;
		     * this method is called on a closed PreparedStatement
			 * or the SQL statement does not return a ResultSet object
		     * @throws 
		     * SQLTimeoutException when the driver has determined that
			 * the timeout value that was specified by the setQueryTimeout method
			 * has been exceeded and has at least attempted to cancel
		     * the currently running Statement
		     */
			k26_resultSet = k26_preStatement.executeQuery();
			
			//데이터베이스가 없다면 데이터베이스 생성
			if(!k26_resultSet.next()){
				Statement k26_statement = k26_connection.createStatement();
				System.out.println("database not found");
				System.out.println("create new database " + k26_DBName);
				String k26_dbSql = "create database if not exists " + k26_DBName;
				
				/* statement.execute(sql)
				 * return true if the first result is a ResultSet object 
			     * return false if it is an update count or there are no results 
			     * create database db_name query는 row의 count를 반환하므로 
			     * return true인 경우 DB 생성 실패를 의미한다. */ 
				if(k26_statement.execute(k26_dbSql)) {
					System.out.println("데이터베이스 생성 실패");
				}
				k26_statement.close();
			} 
			//데이터베이스를 변환 (use database)
			k26_connection.setCatalog(k26_DBName);
		} catch (Exception k26_Error) {
			System.out.println("CreateOrChangeDatabase error : " + k26_Error);
		} finally {
			try{
				if(k26_resultSet != null) {
					k26_resultSet.close();
				}
				if(k26_preStatement != null) {
					k26_preStatement.close();
				}
				if(k26_connection != null) {
					k26_preStatement.close();
				}
			} catch (Exception k26_Error) {
				System.out.println("Close error : " + k26_Error);
				k26_Error.printStackTrace();
			}
		}
	}
	
	public void k26_createTable() {
	 	String createTableQuery 
	 			= k26_stringBuilder.append("create table if not exists ").append(k26_tableName).append("(")
	 							   .append("no int primary key auto_increment")
	 							   .append(", name varchar(100)")
	 							   .append(", weight int")
	 							   .append(", display_size decimal(3, 1)")
	 							   .append(", disk_volume int")
	 							   .append(", etc varchar(100)")
	 							   .append(", price int)").toString();
	 	k26_stringBuilder.setLength(0);
	 	k26_executeQuery(createTableQuery);
	}
	public void k26_executeQuery(String k26_query) {
		Statement k26_statement = null;
		try {
			k26_statement = k26_connection.createStatement();
			 
			/** Statement class. excuteUpdate(String query) method
		      * Executes the given SQL statement, which may be 
		      * an INSERT, UPDATE, or DELETE statement or 
		      * an SQL statement that returns nothing, such as an SQL DDL statement.
			  *
		      * Note:
			  * This method cannot be called on a PreparedStatement or CallableStatement.
			  * 
		      * @param sql an SQL Data Manipulation Language (DML) statement,
		      * such as INSERT, UPDATE or DELETE;
			  * or an SQL statement that returns nothing, such as a DDL statement.
		      *
		      * @return either 
		      * 			  (1) the row count for SQL Data Manipulation Language (DML) statements
		      *            or (2) 0 for SQL statements that return nothing
		      *
		      * @exception 
		      * SQLException if a database access error occurs,
		      * this method is called on a closed Statement,
		      * the given SQL statement produces a ResultSet object,
			  * the method is called on a PreparedStatement or CallableStatement
		      * @throws
		      * SQLTimeoutException when the driver has determined that 
		      * the timeout value that was specified by the setQueryTimeout method
		      * has been exceeded and has at least attempted to cancel the currently running Statement
		      */
			if(k26_statement != null && k26_statement.executeUpdate(k26_query) >= 0) {
			} else {
				System.out.println("Error] Execute fail");
			}
		} catch (SQLException k26_Error) {
			System.out.println(k26_Error.getMessage());
			k26_Error.printStackTrace();
		} finally {
			try {
				if(k26_statement != null) {
					k26_statement.close();
				}	
			} catch(SQLException k26_Error) {
				System.out.println(k26_Error.getMessage());
				k26_Error.printStackTrace();
			}	// end finally try 
		}	// end try
	}
	
	public List<K26_Item> k26_itemDataLoadQuery (String k26_query) {
		List<K26_Item> k26_result = new ArrayList<>();
		Statement k26_statement = null;
		ResultSet k26_resultSet = null;
		try {
			k26_statement = k26_connection.createStatement();
			
			/** Statement Class. excuteQuery(String query) method
		      * Executes the given SQL statement,
			  * which returns a single ResultSet object.

		      * Note:
			  *	This method cannot be called on a PreparedStatement or CallableStatement.
		      * @param sql an SQL statement to be sent to the database, typically a
		      *        static SQL SELECT statement
		      * @return a ResultSet object that contains the data produced by the given query;
			  * 		never null!
		      * @exception SQLException
			  * if a database access error occurs,
		      * this method is called on a closed Statement,
		      * the given SQL statement produces anything other than a single ResultSet object,
		      *  the method is called on a PreparedStatement or CallableStatement
		      * @throws SQLTimeoutException
		      * when the driver has determined that the timeout value
		      * that was specified by the setQueryTimeout method
		      * has been exceeded and has at least attempted to cancel the currently running Statement
		      */
			
			if((k26_resultSet = k26_statement.executeQuery(k26_query)) != null) {
			}
			while (k26_resultSet != null && k26_resultSet.next()) {
				K26_Item k26_item = new K26_Item(
						  k26_resultSet.getInt("no")
						, k26_resultSet.getString("name")
						, k26_resultSet.getInt("weight")
						, k26_resultSet.getDouble("display_size")
						, k26_resultSet.getInt("disk_volume")
						, k26_resultSet.getString("etc")
						, k26_resultSet.getInt("price"));
				k26_result.add(k26_item);
			}	// end while
		} catch (SQLException k26_Error) {
			System.out.println(k26_Error.getMessage());
			k26_Error.printStackTrace();
		} finally {
			try {
				if(k26_statement != null) {
					k26_statement.close();
				}
			} catch(SQLException k26_Error) {
				System.out.println(k26_Error.getMessage());
				k26_Error.printStackTrace();
			}	// end finally try 
		}	// end try
		return k26_result;
	}
	
	public static List<List<String>> k26_dataPrintQuery (String k26_query) {
		List<List<String>> k26_result = new ArrayList<>();
		Statement k26_statement = null;
		ResultSet k26_resultSet = null;
		ResultSetMetaData k26_rsmd = null;
		try {
			k26_statement = k26_connection.createStatement();
			if((k26_resultSet = k26_statement.executeQuery(k26_query)) != null) {
				k26_rsmd = (ResultSetMetaData) k26_resultSet.getMetaData();
			}
			while (k26_resultSet != null && k26_resultSet.next()) {
				List<String> tempList = new ArrayList<>();
				for(int i = 1; i <= k26_rsmd.getColumnCount(); i++) {
					String k26_tempStr = k26_resultSet.getString(i);
					System.out.print(" " + k26_tempStr);
					tempList.add(k26_resultSet.getString(i));
				}
				System.out.println();
				k26_result.add(tempList);
			}	// end while
		} catch (SQLException k26_Error) {
			System.out.println(k26_Error.getMessage());
			k26_Error.printStackTrace();
		} finally {
			try {
				if(k26_statement != null) {
					k26_statement.close();
				}
			} catch(SQLException k26_Error) {
				System.out.println(k26_Error.getMessage());
				k26_Error.printStackTrace();
			}	// end finally try 
		}	// end try
		return k26_result;
	}
}
